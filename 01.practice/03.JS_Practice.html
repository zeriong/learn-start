<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>JS</title>
</head>
<body> sdf
<script>
// let = 하나의 변수만 적용
// ex) let name = "mike";
//     let name = "sam";
//     변수 name은 이미 초기에 "mike"로 지정 되어있기 때문에 에러가 뜸
//
// const = 변하지않는 상수.
// ex) const PI = 3.14;
//     const SPEED_LIMIT = 50;
//     const BIRTH_DAY = '1995-05-18';
//
//=========      let = 변할 수 있는 값 , const = 변하지 않는 값을 선언해준다.      =========
//
// 문자형 String    '' , "" , `` 3가지 다 가능.
// const message1 = "Mike";
// const message2 = "I'm a man.";      문자 중간에 작은 따옴표를 사용해야 할 경우 큰따옴표로 입력
// const message3 = 'I\'m a man.';     작은따옴표를 쓰고싶고 문자열 안에 작은따옴표를 사용하고 싶을땐 역슬러시를 앞에 둬주면 된다.
// <----- 만약에 const name = "Mike"; , const age = '31'; 인경우------->
// const message4 = `My name is ${name}, and I'm ${age}years old.`; 달러뒤에 중괄호 안에 변수가 채워진다. (무조건 백틱)
// const message5 = `저는 ${10+18}살 입니다.`; 이런식으로 굳이 변수가 아니더라도 즉각 표현식으로 넣어도 표출됨.
// console.log(message4)  콘솔로그로 message4 를 표출
//------ 주의!!! 만약 `My name is ${name}, and I'm ${age}years old.` 이렇게 표현할때 백틱인지 따옴표인지 확인.
//
//숫자형 Number
//const num = 1/0;     "infinity" 즉, 무한대로 표기됩니다.
//const y = age/2;     문자를 숫자로 나눈 계산식은 NaN로 표기된다. 이건  Not a Number 즉, 숫자가 아니라는 뜻.
//작업할때 숫자형인데 오류로 nan이 뜨는지 잘 확인하면서 만들자.
//
//Boolean 논리적인 요소를 나타낸다.
//const a = true;  //  참
//const b = false;  //  거짓
//ex) const name = "Mike";
//    const age = 30;
// console.log(name == "Mike")      / true
// console.log(age > 40)            / false
//-----------------------------------------------------------------------------------------------------------------------------------
//null 과 undefined     "null"은 존재하지 않는다는 뜻의 값을 나타내고, undefined는 값이 할당되지 않았다는 뜻
//ex) let age;
//    console.log(age)   let으로 age를 선언만 해주고 할당값을 주지 않는다면 undefined를 표기한다.
//    let user = null;   유저가 존재하지 않는다는 의미로 사용됨.
//
//typeof 변수의 자료형이 어떤 것인지 알아낼 수 있습니다.
//const name = "Mike";
//console.log(typeof 3);          "number"
//console.log(typeof name);       "string"
//console.log(typeof true);       "boolean"
//console.log(typeof "xxx");      "string"
//console.log(typeof null);       "object" = 객체형 (null = 객체가 아니지만 하위호환을 위해 수정하지않는 오류)
//console.log(typeof undefined);  "undefined"
//
//alert 알림창 , prompt 입력받음 , confirm 확인받음------------------------------------------------------------------------------------
//alert() 메세지가 뜨고 확인을 누르기전까지 계속 떠있다.
//prompt() 입력을 받아서 확인과 취소(null) 값을 받아온다.
//ex)  const name = prompt("이름을 입력하세요."); name = 이름을 입력하세요 라는 내용이 적힌 입력받는 박스를 나타낸다. 확인과 취소를 누를 수 있음.
//     alert("환영합니다, " + name + "님");      먼저 prompt가 나와 입력하고 확인을 누르면 받은 값을 name에 표기됩니다. / 취소를 누르면 null
//prompt는 두개의 값을 넣어 줄 수 있다. 먼저 나온 값은 제목, 두번째는 default 즉, 입력창에 적힌다.
//ex)  const name = prompt("예약일을 입력해주세요.", "2022-07-");
//       제목: 예약일을 입력해주세요.  /  검색창: 2022-07-
//confirm() 말 그대로 확인받는다. 얼랏과 다르게 확인과 취소중에 선택 가능.
//ex)  const isAdult = confirm("당신은 성인입니까?");  확인을 누를경우 true , 취소를 누를경우 false (자료형 boolean으로 표기)
//     console.log(isAdult);
//이러한 기본창(기본메서드) js의 단점:-------------------------------------------------------------------------------------------------------------------------
// 1. 일시정지            /     창이 떠 있는동안 스크립트들이 일시정지가 된다.
// 2. 스타일링 X          /     디자이너가 싫어함... 그리고 브라우저마다 모양이 다름. 그래서 결국 디자이너가 싫어함...
//
//변환 종류 / String() 문자형으로 변환 / Number() 숫자형으로 변환 / Boolean() 불린형으로 변환
// 변환이 왜 필요한가?: "100" + "주년" = "100주년"  --------------------------------------------------------------------------------------------------------
//                    100  +  200  =  300
//                   "100" +  200  = ????      의도하지 않는 값이 나올 수 있기때문에 필요하다.
//ex) const mathScore = prompt("수학 몇점?");
//    const engScore = prompt("영어 몇점?");
//    const result = (mathScore + engScore) / 2;
//    console.log(result);
//  만약 처음에 수학몇점에 90, 영어몇점에 80을 입력할 경우 콘솔로그창에는 4540이 나옵니다.
//  이유는 프롬프트에서는 문자형으로 받았기때문에 90+80=170 이 아닌 "90"+"80"="9080"이 되었기 때문입니다.
//  9080은 문자형으로 더하기 되었고 9080은 여전히 문자형인데 나누기 2가 숫자형으로 나눠진 이유는
//  값이 숫자일때 연산기호가 들어갈 경우 자동으로 연산이 됩니다. 이러한 기능을 "자동형 변환"이라 한다.
//  자동으로 변환해줘서 편하다고 생각할 수 있지만 원인을 찾을 수 없는 에러를 야기할 수 있기에 좋기만한 것은 아니다.
//  그렇기에 의도를 가지고 변환해주는 것이 좋다. 그것을 "명시적 형변환"이라 한다.
//console.log(
//   String(3),               첫글자 S는 무조건 대문자 표기  -----------------------------------------------------------------------------------------------
//   String(true),
//   String(false),           콘솔로그 안에 쉼표를 넣어줌으로서 한번에 출력가능.
//   String(null),
//   String(undefined)        "3" "true" "false" "null" "undefined"  이런식으로 문자형을 출력한다.
//   )
//console.log ( Number("123") )                   123
//console.log ( Number("123sad") )                NaN     숫자형으로 변환인데 문자가 들어가서 Not a Number.
//console.log (Number(true) , Number(false) )     1 , 0   특이하게 트루와 펄스는 1과 0으로 출력됩니다. 2인수 프로그래밍처럼...
// Boolean() 은 펼스의 개념만 알면된다.
// 1.숫자0
// 2. 빈 문자열 ""
// 3. null
// 4. undefined       뭔가 비어있는 느낌을 상기.  //  반대로 다른 모든 것은 true.
// 5. NaN
//-------------------------- 주의사항  :  Number(null) = 0    //   Number(undefined) = NaN ---------------------------
//
//연산자 Operators  ( + - * / % ) %는 앞의 변수를 %뒤에 수만큼 나누고 소수점계산을 하지않은 정수의 나머지.-----------------------------------
// %(나머지)는 어디에 쓸까?
// 홀수 : x % 2 = 1          어떤 수든 2로 나눴을때 나머지가 1이면 홀수
// 짝수 : x % 2 = 0          나머지가 0이면 완벽하게 나눠지니 짝수.
//   어떤 값이 들어와도 5를 넘기면 안된다?
//   x % 5 = 0~4  값만 변환.
//   왜냐하면 5로 나눴을때 딱 떨어지면 0이고,
//   딱 떨어지는 값 최대가 5이니 5를 제외한 하위값(0~4)만 반환한다.
//거듭제곱
//const num = 2**3;   2의 3승이라 8을 반환한다.
//  */는 +-보다 우선순위이기 때문에 +-를 먼저 쓰기 위해서는 괄호로 넣어줘야 한다.
//let num = 10;
//num = num + 5;  -----|------- 이 두가지 같은 값이다. num에다가 5를 더한 값을 num에 저장하는 것(다른기호도 마찬가지)
//num += 5;  ----------/
//증가연산자: result = ++num;   증가,감소 둘 다 변수 앞에 붙여야 한다. 뒤로붙이면 더해지기 전의 값이 반환된다.
//감소연산자: result = --num;
//비교 연산자: > , < , <= , >= , == , !=
//여기에서 == 는 동등연산자.
//반환되는 값은 Boolean값으로만 반환
//let a = 1;
//let b = "1";
//console.log(a == b)    숫자와 문자를 비교했는데 true가 나옵니다. 숫자로 자동형변환이 되어 비교가 된 것.
//console.log(a === b)   이렇게 등호를 3개를 붙이면 type까지 비교가 되어 false로 반환된다.
// 문자열과 숫자열이 일치한다고 나올경우 나중에 어떤 버그가 나올지 모르기때문에 주로 일치연산자인 === 를 쓰도록하자.
//-----------------------------------------------------------------------------------------------------------------------------------
//조건문은 아니까 패스   <<   ----   calculatorREMIND.html 참고   ----   >>
//논리연산자도 패스     <<   ----   calculatorREMIND.html 참고   ----   >>
//
//반복문 (loop)----------------------------------------------------------------------------------------------
//for(let i = 1; i <= 10; i++) 세미콜론으로 구역을 나눠주고 총 3개의 구역을 나눌 수 있다.
//console.log(i)
//1. 초기값. 초기에 i를 1이라 선언하고 / 2. 조건.(false가 되면 멈춤) 조건이 true일때 코드를 실행하고 / 3. 코드실행 후 할 작업
// 즉, 처음에 i=1이고 10보다 작으니 코드를 실행합니다. 콘솔로그에 i가 나오게 되어 1이 반환되고 코드실행 후 작업인 3번쨰
// i++ 가되어 기존 1에 1이 더해져서 2가 됩니다. 다음도 마찬가지 i=2이고 10보다 작으니 코드실행 = 콘솔로그 2반환 후 i++가 되어 i=3
// 이런식으로 반복이 되고 i가 10보다 커져버리면 false가 되고 for 문을 빠져나온다.
//while(i <= 10) { console.log(i) i++; }
// 와일에 조건이 맞는경우 코드를 실행시키고 그 후 i++를 실행한다. 마찬가지로 false일때 while문을 빠져나온다
//do... while문 와일문과 비슷하지만 do에서 조건을 먼저 실행시켜준다는 점이 다르다.
//let i = 1;
//do { console.log(i) i++; }
//while (i <= 10);
// 콘솔로그를 반환하고 i에 1을 더하고 while의 조건이 맞을경우 다시 do로 돌아간다 마찬가지로 while문이 false가 되면 빠져나온다.
//반복문을 빠져나오는 기능 break, continue
//break: 만나는 즉시 멈추고 반복문을 빠져나온다.
//continue: 멈추고 다음 반복으로 점프해서 진행
//ex) while(true){
//       let answer = confirm("계속 할까요?")
//       if(!answer){                           와일문 조건을 만족할경우 계속해서 반복하다가
//       break                                  confirm에서 취소를 눌러 false가 되면 break를 만나 반복문을 즉시 빠져나온다.
//       }
//    }
//    for(let i = 0; i <= 10; i++){       if(i%2) 이건 i를 2로 나눴을때 나머지가 1인지 0인지 구별하여 1은 true, 0은 false로
//      if(i%2){                          Boolean형으로 자동형변환된다. 즉, i가 0일땐 2로 나눠도 나머지가 0이라 false가 되어 if문을 지나치고
//         continue;                      콘솔로그에 반환되고 3번째 구역의 i++가 적용되어  i는 1이된다. 그럼 1나누기 2는 나머지가 1이라
//      }                                 true가 되어 이프문을 들어가서 continue를 만나서 다음 반복문인 콘솔로그를 건너뛰고 i++가 되어
//      console.log(i)                    i = 2가 된다. 그러면 2/2의 나머지는 0이기 때문에 이프문을 들어가지못하고 바로 콘솔로그로 반환된다.
//    }                                   이렇게 반복되어 콘솔로그에 0 2 4 8 10 이렇게 찍히게 된다.
//
//switch 그냥 if elseif 문과 같지만 케이스가 많은경우 더 간결하게 쓸 수 있는 장점이 있다.-----------------------------------------------------------------------------------------------------------------------------------
//ex) let fruit = prompt("무슨 과일을 사고싶나요?" , "입력하시면 가격이 나옵니다.")
//    switch(fruit){
//       case "사과" :
//         alert ("100원 입니다.")
//         break;
//       case "바나나"
//         alert ("200원 입니다.")
//         break;
//       case "키위" :
//         alert ("300원 입니다.")        break를 넣지 않을경우 다음값이 실행된다.
//         break;
//       case "멜론"
//         alert ("400원 입니다.")
//         break;
//       case "수박" :
//         alert ("500원 입니다.")
//         break;
//       default :
//         alert ("없는 과일입니다.")
//         break;
//    }
//function 헷갈려하는 부분.----------------------------------------------------------------------------------------------
//   let name = "Mike";
//   function sayHello(name) {                 전역 변수 name = 'Mike' 이지만 함수 sayHello에서는 매게변수로 name을 선언 해줘서
//      let newName = name || "friend";        로컬변수로 name이 현재 선언만 되었고 아무것도 아닌상태라서 defined 이므로 false이다.
//      let msg = `Hello, ${newName}`          그러고 로컬변수로 newName은 || 을 이용해서 name이거나 friend이라는 규칙을 만들어 주고
//      console.log(msg)                       name은 false상태이므로 저장되지않고 friend로 저장된다. (||는 마지막 ture값을 반환한다.)
//   }                                         그러고 로컬변수 msg에 `Hello, ${newName}`를 넣어서 sayHello이 실행되면 다음과 같다.
//   sayHello();                              "Hello, friend"  /  초기 name과 같은 비어있는 상태라서 false가 되고 ||의 true인 friend 반환
//   satHello("Jane");                        "Hello, Jane"    /  name에 "Jane"이라는 문자열 true가 들어가서 name이 먼저 true가 되어 Jane을 반환
// 위에 코딩을 좀 간단하게 줄여본다면-------
//   function sayHello( name = 'friend' ) {   default값을 friend로 주어서 매게변수가 없을 경우 friend로 반환 하게 해줌으로서
//      let msg = `Hello, ${name}`            콘솔로그에 "Hello, friend" , "Hello, Jane" 를 반환하게 된다.
//      console.log(msg)
//   }
//   sayHello();
//   satHello("Jane");
//
//return 으로 값 반환 가능
// function add(num1,num2) {           매게변수로 넘1,넘2 두개의 자리를 만들어주고 (현재는 둘다 디폴트값)
//    return num1 + num2;              반환되는 값은(return은) num1 + num2 이다.
// }                                   따라서 result = add(2,3); 을 선언 해주었기땜에
// const result = add(2,3);            result = ( num1 + num2 ) = ( 2 + 3 ) = ( 5 )가 된다.
// console.log(result)
//근데 리턴이 없어도 출력되거나 반환되거나 잘 된다. return을 쓸 경우 리턴 오른쪽의 코드를 실행하고 종료된다. 그래서 멈추는 용도로 쓰인다.
//ex) function showError(){
//        alert('에러가 발생했습니다.');               처음에 얼랏이 실행되고 리턴으로 넘어가는데 리턴 오른쪽에 아무것도 없는 상태라서
//        return;                                   그 이후의 얼랏은 실행되지않고 코드는 진행되지않는다.
//        alert('이 코드는 절대 실행되지 않습니다.');    그리고 return이든 return을 넣지 않든 간에 둘 다 콘솔로그에 undefined를 반환한다.
//    }
//    const result = showError();
//    console.log(result);
//----------------------------------------------------------------------------------------------------------------------------------------------
//함수 선언문 :  function sayHello() { console.log('Hello'); }
//함수 표현식 :  let sayHello = function() { console.log('Hello'); }
//호출 방식이 두개가 다른데 선언문의 경우 내가 많이 해봤잖아 어디에서 호출하든 다 호출이 된다. 그 이유는 자바스크립트의 알고리즘때문이다.
//선언 된 함수를 모아두고 눈으로 봤을땐 함수적용 범위가 function쪽에 한정되어있어 보이지만 실제로는 함수를 모아둔 알고리즘때문에 어디서든 함수선언이 가능하다.
//이걸 호이스트라고 한다
//                    < 호출ok >                                           < 호출ok >
// function sayHello() { console.log('Hello'); }    /      sayHello()
// sayHello()                                       /      function sayHello() { console.log('Hello'); }
//표현식 의 경우는 순서대로 나와야만 호출이 가능해서 선언문으로 선언 후 호출해야만 가능
//                    < 호출ok >                                           < 호출 no! >
// let sayHello = function() { console.log('Hello'); }        /        sayHello()
// sayHello()                                                 /        let sayHello = function() { console.log('Hello'); }
//
//화살표 함수(arrow funtion)//----------------------------------------------------------------------------------------------------------------------------------------------
//let add = function(num1, num2) { return num1 + num2; }
//아래와 같이 펑션을 없애고 괄호 뒤에 => 화살표만 붙는다
//
//let add = (num1 , num2) => { return num1 + num2; }
//그리고 이 상태에서 코드 본문이 1줄이고 리턴문이기에 리턴을 없애고 일반괄호로 바꿀 수 있다.
//
//let add = (num1 , num2) => ( num1 + num2; )
//리턴문이 한줄이면 괄호도 없앨 수 있다.
//
//let add = (num1 , num2) => num1 + num2;
//완성.
//
//let sayHello = (name) => `Hello, ${name}`;
//괄호안에 인수가 하나일 경우 아래와 같이 괄호생략 가능
//let sayHello = name => `Hello, ${name}`;
//완성.
//
//let showError = () => { alert('error!') }
//인수가 없는 경우라면 괄호생략이 불가능함.
//
//let add = function(num1, num2){ const result = num1 + num2;
//                                return result; }
// 위와 같이 리턴이 있어도 여러줄의 코드가 있기때문에 괄호생략이 불가능하다.
//
//let add = (num1, num2) => { const result = num1 + num2;
//                            return result; }
// 이렇게 화살표 함수로만 바꿔 줄 수 있는 상황이다.
//
//Object 객체//----------------------------------------------------------------------------------------------------------------------------------------------
// const superman = {
//   name : 'clark',         슈퍼맨 객체를 만들었다. 객체는 중괄호로 만들고
//   age : 33,               key와 값(value)으로 구성된 프로퍼티로 구성되고 프로퍼티는 쉼표로 구분한다
// }                         마지막 쉼표는 없어도 되지만 추가 수정 삭제할때 용이해서 찍는게 낫다.
//객체에 접근할때는 . or [] 이용한다.
//ex) superman.name     // 'clark'
//    superman['age']   //  33
//객체에 추가할때도 마찬가지 . 이나 [] 이용하고 = 를 이용해서 추가한다.
//ex) superman.gender = 'male';
//    superman['hairColor'] = 'black';
//객체 삭제는 (delete) + (객체이름) + ( . ) + (삭제하고자 하는 프로퍼티)
//ex) delete superman.hairColor;
//
//단축 프로퍼티_______________________________________                ___________________________
//const name = 'clark';   |    const superman = {  |               |   const superman = {     |
//const age = 33;         |      name : name,      |               |     name,                |
//                        |      age : age,        |   ---->       |     age,                 |
//                        |      gender : 'male',  |               |     gender : 'male',     |
//                        |      }                 |               |     }                    |
//--------------------------------------------------               ----------------------------
//선언된 변수의 이름과 객체 프로퍼티의 이름이 같을 경우 단축할 수 있다.
//위 단축프로퍼티와 같은 코드에서 오브젝트 프로퍼티존재여부 확인--------------------------------------------------------------------------------------------------
// superman.birthDay;       존재하지않는 프로퍼티에 접근하면 에러가 뜨지않고 undefined로 반환
// 'birthDay' in superman;  슈퍼맨객체 안에 벌스데이가 있는가? 라는 뜻이라 false로 반환
// 'age' in superman;       슈퍼맨객체 안에 에이쥐가 있는가? = true 반환
//
//객체를 선언해주고서 for ... in 문으로 반환하기

/*let list1 = {
    name: "Mike",
    age: 30,
};
let list2 = [
    { name: "제룡", age: 10},
    { name: "혜지", age: 20}
];
let list3 = [
    "제룡",
    "혜지"
];

console.log(list1["age"]);
console.log("-------------------");
console.log(list2[0]["name"]);
console.log(list2[1]["name"]);
console.log("-------------------");
console.log(list3[1]);*/

    /*for(key in Mike){             //마이크 안에 있는 프로퍼티를 key라고 선언해주었다.
      console.log(key)            //key는  'name' 'age' 로 반환된다. key의 구역은 값이 아닌 키 이기때문.
      console.log(Mike.key)       //그러고 접근을 하게되면?????????????????????
    }*/
 let boy = {
     name: "Mike",
     showName: function () {
         console.log(boy.name)
     }
 };
boy.showName();
</script>
</body>
</html>